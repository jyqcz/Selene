# 同步上游仓库全部 release（包括最新版）
# 说明：
# - 会分页获取上游仓库的所有 releases（per_page=100），逐个检查本仓库是否已有相同 tag。
# - 若本仓库不存在该 tag 的 release，则会：
#     1) 下载上游 release 的所有 assets（放到 upstream-assets/<tag>/）
#     2) 通过 GitHub Releases API 在当前仓库创建同名 release（保留 name、body、draft、prerelease）
#     3) 上传对应的 assets 到新创建的 release
# - 定时与手动触发均支持。请确保本仓库的 secrets.GITHUB_TOKEN 有权限创建 release 与上传资产。
# - 反转从api获取的顺序以按照从旧到新创建release
name: Sync Upstream Releases

on:
  workflow_dispatch: {}
  schedule:
    - cron: '0 */6 * * *' # 每 6 小时运行一次

concurrency:
  group: sync-upstream-releases
  cancel-in-progress: false

jobs:
  sync-releases:
    runs-on: ubuntu-latest
    env:
      UPSTREAM_OWNER: wya0
      UPSTREAM_REPO: Selene
      PER_PAGE: "100"
    steps:
      - name: Checkout repo (needed for GitHub context)
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq
      - name: Sync all upstream releases to this repo
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          set -euo pipefail
          UPSTREAM="${UPSTREAM_OWNER}/${UPSTREAM_REPO}"
          echo "Syncing releases from $UPSTREAM into ${GITHUB_REPOSITORY}"
          mkdir -p upstream-assets
          page=1
          # 创建临时文件来存储所有 releases
          temp_file=$(mktemp)
          while true; do
            echo "Fetching releases page $page"
            releases=$(curl -s -H "Authorization: token $GH_TOKEN" \
              "https://api.github.com/repos/${UPSTREAM_OWNER}/${UPSTREAM_REPO}/releases?per_page=${PER_PAGE}&page=${page}")
            # 如果本页没有条目则结束
            count=$(echo "$releases" | jq 'length')
            if [ "$count" -eq 0 ]; then
              echo "No more releases (page $page empty)."
              break
            fi
            echo "Processing $count releases from page $page"
            # 将本页 releases 追加到临时文件
            echo "$releases" | jq -c '.[]' >> "$temp_file"
            page=$((page + 1))
          done
          echo "All pages fetched. Total releases: $(wc -l < "$temp_file")"
          echo "Processing releases in reverse order (oldest first)..."
          # 使用 tac 命令将临时文件内容反转（最后一行变成第一行）
          tac "$temp_file" | while read -r rel; do
            tag_name=$(echo "$rel" | jq -r '.tag_name')
            # 防止空 tag
            if [ -z "$tag_name" ] || [ "$tag_name" = "null" ]; then
              echo "Skipping release with empty tag"
              continue
            fi
            release_name=$(echo "$rel" | jq -r '.name // ""')
            release_body=$(echo "$rel" | jq -r '.body // ""')
            draft=$(echo "$rel" | jq -r '.draft')
            prerelease=$(echo "$rel" | jq -r '.prerelease')
            created_at=$(echo "$rel" | jq -r '.created_at')
            echo "Checking tag $tag_name (created: $created_at)..."
            status_code=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: token $GH_TOKEN" \
              "https://api.github.com/repos/${GITHUB_REPOSITORY}/releases/tags/${tag_name}")
            if [ "$status_code" -eq 200 ]; then
              echo "Release with tag $tag_name already exists in ${GITHUB_REPOSITORY}, skipping."
              continue
            fi
            echo "Downloading assets for $tag_name (if any)..."
            safe_dir="upstream-assets/$(echo "$tag_name" | sed 's/[^A-Za-z0-9._-]/_/g')"
            mkdir -p "$safe_dir"
            echo "$rel" | jq -r '.assets[]?.browser_download_url' | while read -r asset_url; do
              if [ -z "$asset_url" ] || [ "$asset_url" = "null" ]; then
                continue
              fi
              fname=$(basename "$asset_url")
              echo "  - Downloading $fname"
              # 使用 -L 跟随重定向
              curl -sL -H "Authorization: token $GH_TOKEN" "$asset_url" -o "${safe_dir}/${fname}"
            done
            echo "Creating release $tag_name in ${GITHUB_REPOSITORY}..."
            # 构造 payload（保留 draft & prerelease）
            payload=$(jq -nc --arg tag "$tag_name" --arg name "$release_name" --arg body "$release_body" \
              --argjson draft "$draft" --argjson prerelease "$prerelease" \
              '{ tag_name: $tag, name: $name, body: $body, draft: $draft, prerelease: $prerelease }')
            create_resp=$(curl -s -H "Authorization: token $GH_TOKEN" -H "Accept: application/vnd.github.v3+json" \
              -d "$payload" "https://api.github.com/repos/${GITHUB_REPOSITORY}/releases")
            upload_url=$(echo "$create_resp" | jq -r '.upload_url // empty')
            message=$(echo "$create_resp" | jq -r '.message // empty')
            if [ -z "$upload_url" ]; then
              echo "Failed to create release for $tag_name: $message"
              # 继续处理下一个 release，而不是退出整个流程
              continue
            fi
            echo "Upload URL obtained. Uploading assets for $tag_name..."
            if compgen -G "${safe_dir}/*" > /dev/null; then
              for f in "${safe_dir}"/*; do
                [ -f "$f" ] || continue
                fname=$(basename "$f")
                echo "  - Uploading $fname ..."
                # upload_url 包含 "{?name,label}"，去掉括号部分并附加 ?name=...
                upload_endpoint="${upload_url%\{*}?name=${fname}"
                curl -s --fail -X POST -H "Authorization: token $GH_TOKEN" \
                  -H "Content-Type: application/octet-stream" --data-binary @"$f" "$upload_endpoint" \
                  || echo "    Warning: failed to upload asset $fname for $tag_name"
              done
            else
              echo "  - No assets to upload for $tag_name."
            fi
            echo "Release $tag_name created successfully (if no errors above)."
          done
          # 清理临时文件
          rm -f "$temp_file"
          echo "All releases processed in reverse order."
